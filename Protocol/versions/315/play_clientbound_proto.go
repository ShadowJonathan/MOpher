// Generated by protocol_builder
// Do not edit

package _315

import (
	"github.com/ShadowJonathan/mopher/Protocol/lib"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"math"
)

func (s *SpawnObject) Id() int { return 0 }
func (s *SpawnObject) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = lib.WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	if err = s.UUID.Serialize(ww); err != nil {
		return
	}
	tmp[0] = byte(s.Type >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp0 := math.Float64bits(s.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(s.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(s.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.Data >> 24)
	tmp[1] = byte(s.Data >> 16)
	tmp[2] = byte(s.Data >> 8)
	tmp[3] = byte(s.Data >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityX >> 8)
	tmp[1] = byte(s.VelocityX >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityY >> 8)
	tmp[1] = byte(s.VelocityY >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityZ >> 8)
	tmp[1] = byte(s.VelocityZ >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	return
}
func (s *SpawnObject) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if s.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if err = s.UUID.Deserialize(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Type = (byte(tmp[0]) << 0)
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Z = math.Float64frombits(tmp2)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Pitch = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	s.Data = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityX = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityY = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityZ = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	return
}

func (s *SpawnExperienceOrb) Id() int { return 1 }
func (s *SpawnExperienceOrb) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	if err = lib.WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	tmp[0] = byte(s.X >> 24)
	tmp[1] = byte(s.X >> 16)
	tmp[2] = byte(s.X >> 8)
	tmp[3] = byte(s.X >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(s.Y >> 24)
	tmp[1] = byte(s.Y >> 16)
	tmp[2] = byte(s.Y >> 8)
	tmp[3] = byte(s.Y >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(s.Z >> 24)
	tmp[1] = byte(s.Z >> 16)
	tmp[2] = byte(s.Z >> 8)
	tmp[3] = byte(s.Z >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(s.Count >> 8)
	tmp[1] = byte(s.Count >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	return
}
func (s *SpawnExperienceOrb) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if s.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	s.X = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	s.Y = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	s.Z = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.Count = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	return
}

func (s *SpawnGlobalEntity) Id() int { return 2 }
func (s *SpawnGlobalEntity) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = lib.WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	tmp[0] = byte(s.Type >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.X >> 56)
	tmp[1] = byte(s.X >> 48)
	tmp[2] = byte(s.X >> 40)
	tmp[3] = byte(s.X >> 32)
	tmp[4] = byte(s.X >> 24)
	tmp[5] = byte(s.X >> 16)
	tmp[6] = byte(s.X >> 8)
	tmp[7] = byte(s.X >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Y >> 56)
	tmp[1] = byte(s.Y >> 48)
	tmp[2] = byte(s.Y >> 40)
	tmp[3] = byte(s.Y >> 32)
	tmp[4] = byte(s.Y >> 24)
	tmp[5] = byte(s.Y >> 16)
	tmp[6] = byte(s.Y >> 8)
	tmp[7] = byte(s.Y >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Z >> 56)
	tmp[1] = byte(s.Z >> 48)
	tmp[2] = byte(s.Z >> 40)
	tmp[3] = byte(s.Z >> 32)
	tmp[4] = byte(s.Z >> 24)
	tmp[5] = byte(s.Z >> 16)
	tmp[6] = byte(s.Z >> 8)
	tmp[7] = byte(s.Z >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	return
}
func (s *SpawnGlobalEntity) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if s.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Type = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.X = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.Y = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.Z = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	return
}

func (s *SpawnMob) Id() int { return 3 }
func (s *SpawnMob) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = lib.WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	if err = s.UUID.Serialize(ww); err != nil {
		return
	}
	tmp[0] = byte(s.Type >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.X >> 56)
	tmp[1] = byte(s.X >> 48)
	tmp[2] = byte(s.X >> 40)
	tmp[3] = byte(s.X >> 32)
	tmp[4] = byte(s.X >> 24)
	tmp[5] = byte(s.X >> 16)
	tmp[6] = byte(s.X >> 8)
	tmp[7] = byte(s.X >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Y >> 56)
	tmp[1] = byte(s.Y >> 48)
	tmp[2] = byte(s.Y >> 40)
	tmp[3] = byte(s.Y >> 32)
	tmp[4] = byte(s.Y >> 24)
	tmp[5] = byte(s.Y >> 16)
	tmp[6] = byte(s.Y >> 8)
	tmp[7] = byte(s.Y >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Z >> 56)
	tmp[1] = byte(s.Z >> 48)
	tmp[2] = byte(s.Z >> 40)
	tmp[3] = byte(s.Z >> 32)
	tmp[4] = byte(s.Z >> 24)
	tmp[5] = byte(s.Z >> 16)
	tmp[6] = byte(s.Z >> 8)
	tmp[7] = byte(s.Z >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.HeadPitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityX >> 8)
	tmp[1] = byte(s.VelocityX >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityY >> 8)
	tmp[1] = byte(s.VelocityY >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(s.VelocityZ >> 8)
	tmp[1] = byte(s.VelocityZ >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	if err = lib.WriteMetadata(ww, s.Metadata); err != nil {
		return
	}
	return
}
func (s *SpawnMob) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if s.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if err = s.UUID.Deserialize(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Type = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.X = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.Y = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.Z = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Pitch = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.HeadPitch = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityX = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityY = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	s.VelocityZ = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if s.Metadata, err = lib.ReadMetadata(rr); err != nil {
		return
	}
	return
}

func (s *SpawnPainting) Id() int { return 4 }
func (s *SpawnPainting) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = lib.WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	if err = s.UUID.Serialize(ww); err != nil {
		return
	}
	if err = lib.WriteString(ww, s.Title); err != nil {
		return
	}
	tmp[0] = byte(s.Location >> 56)
	tmp[1] = byte(s.Location >> 48)
	tmp[2] = byte(s.Location >> 40)
	tmp[3] = byte(s.Location >> 32)
	tmp[4] = byte(s.Location >> 24)
	tmp[5] = byte(s.Location >> 16)
	tmp[6] = byte(s.Location >> 8)
	tmp[7] = byte(s.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Direction >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (s *SpawnPainting) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if s.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if err = s.UUID.Deserialize(rr); err != nil {
		return
	}
	if s.Title, err = lib.ReadString(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.Location = (lib.Position(tmp[7]) << 0) | (lib.Position(tmp[6]) << 8) | (lib.Position(tmp[5]) << 16) | (lib.Position(tmp[4]) << 24) | (lib.Position(tmp[3]) << 32) | (lib.Position(tmp[2]) << 40) | (lib.Position(tmp[1]) << 48) | (lib.Position(tmp[0]) << 56)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Direction = (byte(tmp[0]) << 0)
	return
}

func (s *SpawnPlayer) Id() int { return 5 }
func (s *SpawnPlayer) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = lib.WriteVarInt(ww, s.EntityID); err != nil {
		return
	}
	if err = s.UUID.Serialize(ww); err != nil {
		return
	}
	tmp0 := math.Float64bits(s.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(s.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(s.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(s.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(s.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteMetadata(ww, s.Metadata); err != nil {
		return
	}
	return
}
func (s *SpawnPlayer) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if s.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if err = s.UUID.Deserialize(rr); err != nil {
		return
	}
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	s.Z = math.Float64frombits(tmp2)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Pitch = int8((uint8(tmp[0]) << 0))
	if s.Metadata, err = lib.ReadMetadata(rr); err != nil {
		return
	}
	return
}

func (a *Animation) Id() int { return 6 }
func (a *Animation) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = lib.WriteVarInt(ww, a.EntityID); err != nil {
		return
	}
	tmp[0] = byte(a.AnimationID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (a *Animation) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if a.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	a.AnimationID = (byte(tmp[0]) << 0)
	return
}

func (s *Statistics) Id() int { return 7 }
func (s *Statistics) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, lib.VarInt(len(s.Statistics))); err != nil {
		return
	}
	for tmp0 := range s.Statistics {
		if err = lib.WriteString(ww, s.Statistics[tmp0].Name); err != nil {
			return
		}
		if err = lib.WriteVarInt(ww, s.Statistics[tmp0].Value); err != nil {
			return
		}
	}
	return
}
func (s *Statistics) Read(rr io.Reader) (err error) {
	var tmp0 lib.VarInt
	if tmp0, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	s.Statistics = make([]Statistic, tmp0)
	for tmp1 := range s.Statistics {
		if s.Statistics[tmp1].Name, err = lib.ReadString(rr); err != nil {
			return
		}
		if s.Statistics[tmp1].Value, err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (b *BlockBreakAnimation) Id() int { return 8 }
func (b *BlockBreakAnimation) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = lib.WriteVarInt(ww, b.EntityID); err != nil {
		return
	}
	tmp[0] = byte(b.Location >> 56)
	tmp[1] = byte(b.Location >> 48)
	tmp[2] = byte(b.Location >> 40)
	tmp[3] = byte(b.Location >> 32)
	tmp[4] = byte(b.Location >> 24)
	tmp[5] = byte(b.Location >> 16)
	tmp[6] = byte(b.Location >> 8)
	tmp[7] = byte(b.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(b.Stage >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (b *BlockBreakAnimation) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if b.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	b.Location = (lib.Position(tmp[7]) << 0) | (lib.Position(tmp[6]) << 8) | (lib.Position(tmp[5]) << 16) | (lib.Position(tmp[4]) << 24) | (lib.Position(tmp[3]) << 32) | (lib.Position(tmp[2]) << 40) | (lib.Position(tmp[1]) << 48) | (lib.Position(tmp[0]) << 56)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	b.Stage = int8((uint8(tmp[0]) << 0))
	return
}

func (u *UpdateBlockEntity) Id() int { return 9 }
func (u *UpdateBlockEntity) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(u.Location >> 56)
	tmp[1] = byte(u.Location >> 48)
	tmp[2] = byte(u.Location >> 40)
	tmp[3] = byte(u.Location >> 32)
	tmp[4] = byte(u.Location >> 24)
	tmp[5] = byte(u.Location >> 16)
	tmp[6] = byte(u.Location >> 8)
	tmp[7] = byte(u.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(u.Action >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteNBT(ww, u.NBT); err != nil {
		return
	}
	return
}
func (u *UpdateBlockEntity) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	u.Location = (lib.Position(tmp[7]) << 0) | (lib.Position(tmp[6]) << 8) | (lib.Position(tmp[5]) << 16) | (lib.Position(tmp[4]) << 24) | (lib.Position(tmp[3]) << 32) | (lib.Position(tmp[2]) << 40) | (lib.Position(tmp[1]) << 48) | (lib.Position(tmp[0]) << 56)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	u.Action = (byte(tmp[0]) << 0)
	if u.NBT, err = lib.ReadNBT(rr); err != nil {
		return
	}
	return
}

func (b *BlockAction) Id() int { return 10 }
func (b *BlockAction) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(b.Location >> 56)
	tmp[1] = byte(b.Location >> 48)
	tmp[2] = byte(b.Location >> 40)
	tmp[3] = byte(b.Location >> 32)
	tmp[4] = byte(b.Location >> 24)
	tmp[5] = byte(b.Location >> 16)
	tmp[6] = byte(b.Location >> 8)
	tmp[7] = byte(b.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(b.Byte1 >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(b.Byte2 >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, b.BlockType); err != nil {
		return
	}
	return
}
func (b *BlockAction) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	b.Location = (lib.Position(tmp[7]) << 0) | (lib.Position(tmp[6]) << 8) | (lib.Position(tmp[5]) << 16) | (lib.Position(tmp[4]) << 24) | (lib.Position(tmp[3]) << 32) | (lib.Position(tmp[2]) << 40) | (lib.Position(tmp[1]) << 48) | (lib.Position(tmp[0]) << 56)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	b.Byte1 = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	b.Byte2 = (byte(tmp[0]) << 0)
	if b.BlockType, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (b *BlockChange) Id() int { return 11 }
func (b *BlockChange) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(b.Location >> 56)
	tmp[1] = byte(b.Location >> 48)
	tmp[2] = byte(b.Location >> 40)
	tmp[3] = byte(b.Location >> 32)
	tmp[4] = byte(b.Location >> 24)
	tmp[5] = byte(b.Location >> 16)
	tmp[6] = byte(b.Location >> 8)
	tmp[7] = byte(b.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, b.BlockID); err != nil {
		return
	}
	return
}
func (b *BlockChange) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	b.Location = (lib.Position(tmp[7]) << 0) | (lib.Position(tmp[6]) << 8) | (lib.Position(tmp[5]) << 16) | (lib.Position(tmp[4]) << 24) | (lib.Position(tmp[3]) << 32) | (lib.Position(tmp[2]) << 40) | (lib.Position(tmp[1]) << 48) | (lib.Position(tmp[0]) << 56)
	if b.BlockID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (b *BossBar) Id() int { return 12 }
func (b *BossBar) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	if err = b.UUID.Serialize(ww); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, b.Action); err != nil {
		return
	}
	if b.Action == 0 || b.Action == 3 {
		var tmp0 []byte
		if tmp0, err = json.Marshal(&b.Title); err != nil {
			return
		}
		tmp1 := string(tmp0)
		if err = lib.WriteString(ww, tmp1); err != nil {
			return
		}
	}
	if b.Action == 0 || b.Action == 2 {
		tmp2 := math.Float32bits(b.Health)
		tmp[0] = byte(tmp2 >> 24)
		tmp[1] = byte(tmp2 >> 16)
		tmp[2] = byte(tmp2 >> 8)
		tmp[3] = byte(tmp2 >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
	}
	if b.Action == 0 || b.Action == 4 {
		if err = lib.WriteVarInt(ww, b.Color); err != nil {
			return
		}
		if err = lib.WriteVarInt(ww, b.Style); err != nil {
			return
		}
	}
	if b.Action == 0 || b.Action == 5 {
		tmp[0] = byte(b.Flags >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
	}
	return
}
func (b *BossBar) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if err = b.UUID.Deserialize(rr); err != nil {
		return
	}
	if b.Action, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if b.Action == 0 || b.Action == 3 {
		var tmp0 string
		if tmp0, err = lib.ReadString(rr); err != nil {
			return err
		}
		if err = json.Unmarshal([]byte(tmp0), &b.Title); err != nil {
			return
		}
	}
	if b.Action == 0 || b.Action == 2 {
		var tmp1 uint32
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
		b.Health = math.Float32frombits(tmp1)
	}
	if b.Action == 0 || b.Action == 4 {
		if b.Color, err = lib.ReadVarInt(rr); err != nil {
			return
		}
		if b.Style, err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	if b.Action == 0 || b.Action == 5 {
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		b.Flags = (byte(tmp[0]) << 0)
	}
	return
}

func (s *ServerDifficulty) Id() int { return 13 }
func (s *ServerDifficulty) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	tmp[0] = byte(s.Difficulty >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (s *ServerDifficulty) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Difficulty = (byte(tmp[0]) << 0)
	return
}

func (t *TabCompleteReply) Id() int { return 14 }
func (t *TabCompleteReply) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, t.Count); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, lib.VarInt(len(t.Matches))); err != nil {
		return
	}
	for tmp0 := range t.Matches {
		if err = lib.WriteString(ww, t.Matches[tmp0]); err != nil {
			return
		}
	}
	return
}
func (t *TabCompleteReply) Read(rr io.Reader) (err error) {
	if t.Count, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 lib.VarInt
	if tmp0, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	t.Matches = make([]string, tmp0)
	for tmp1 := range t.Matches {
		if t.Matches[tmp1], err = lib.ReadString(rr); err != nil {
			return
		}
	}
	return
}

func (s *ServerMessage) Id() int { return 15 }
func (s *ServerMessage) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	var tmp0 []byte
	if tmp0, err = json.Marshal(&s.Message); err != nil {
		return
	}
	tmp1 := string(tmp0)
	if err = lib.WriteString(ww, tmp1); err != nil {
		return
	}
	tmp[0] = byte(s.Type >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (s *ServerMessage) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	var tmp0 string
	if tmp0, err = lib.ReadString(rr); err != nil {
		return err
	}
	if err = json.Unmarshal([]byte(tmp0), &s.Message); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Type = (byte(tmp[0]) << 0)
	return
}

func (m *MultiBlockChange) Id() int { return 16 }
func (m *MultiBlockChange) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(m.ChunkX >> 24)
	tmp[1] = byte(m.ChunkX >> 16)
	tmp[2] = byte(m.ChunkX >> 8)
	tmp[3] = byte(m.ChunkX >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(m.ChunkZ >> 24)
	tmp[1] = byte(m.ChunkZ >> 16)
	tmp[2] = byte(m.ChunkZ >> 8)
	tmp[3] = byte(m.ChunkZ >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, lib.VarInt(len(m.Records))); err != nil {
		return
	}
	for tmp0 := range m.Records {
		tmp[0] = byte(m.Records[tmp0].XZ >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(m.Records[tmp0].Y >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		if err = lib.WriteVarInt(ww, m.Records[tmp0].BlockID); err != nil {
			return
		}
	}
	return
}
func (m *MultiBlockChange) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	m.ChunkX = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	m.ChunkZ = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	var tmp0 lib.VarInt
	if tmp0, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	m.Records = make([]BlockChangeRecord, tmp0)
	for tmp1 := range m.Records {
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Records[tmp1].XZ = (byte(tmp[0]) << 0)
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Records[tmp1].Y = (byte(tmp[0]) << 0)
		if m.Records[tmp1].BlockID, err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (c *ConfirmTransaction) Id() int { return 17 }
func (c *ConfirmTransaction) Write(ww io.Writer) (err error) {
	var tmp [2]byte
	tmp[0] = byte(c.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(c.ActionNumber >> 8)
	tmp[1] = byte(c.ActionNumber >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	if err = lib.WriteBool(ww, c.Accepted); err != nil {
		return
	}
	return
}
func (c *ConfirmTransaction) Read(rr io.Reader) (err error) {
	var tmp [2]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	c.ID = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	c.ActionNumber = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if c.Accepted, err = lib.ReadBool(rr); err != nil {
		return
	}
	return
}

func (w *WindowClose) Id() int { return 18 }
func (w *WindowClose) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	tmp[0] = byte(w.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (w *WindowClose) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.ID = (byte(tmp[0]) << 0)
	return
}

func (w *WindowOpen) Id() int { return 19 }
func (w *WindowOpen) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(w.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteString(ww, w.Type); err != nil {
		return
	}
	var tmp0 []byte
	if tmp0, err = json.Marshal(&w.Title); err != nil {
		return
	}
	tmp1 := string(tmp0)
	if err = lib.WriteString(ww, tmp1); err != nil {
		return
	}
	tmp[0] = byte(w.SlotCount >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if w.Type == "EntityHorse" {
		tmp[0] = byte(w.EntityID >> 24)
		tmp[1] = byte(w.EntityID >> 16)
		tmp[2] = byte(w.EntityID >> 8)
		tmp[3] = byte(w.EntityID >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
	}
	return
}
func (w *WindowOpen) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.ID = (byte(tmp[0]) << 0)
	if w.Type, err = lib.ReadString(rr); err != nil {
		return
	}
	var tmp0 string
	if tmp0, err = lib.ReadString(rr); err != nil {
		return err
	}
	if err = json.Unmarshal([]byte(tmp0), &w.Title); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.SlotCount = (byte(tmp[0]) << 0)
	if w.Type == "EntityHorse" {
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		w.EntityID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	}
	return
}

func (w *WindowItems) Id() int { return 20 }
func (w *WindowItems) Write(ww io.Writer) (err error) {
	var tmp [2]byte
	tmp[0] = byte(w.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(int16(len(w.Items)) >> 8)
	tmp[1] = byte(int16(len(w.Items)) >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	for tmp0 := range w.Items {
		if err = w.Items[tmp0].Serialize(ww); err != nil {
			return
		}
	}
	return
}
func (w *WindowItems) Read(rr io.Reader) (err error) {
	var tmp [2]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.ID = (byte(tmp[0]) << 0)
	var tmp0 int16
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	tmp0 = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	w.Items = make([]lib.ItemStack, tmp0)
	for tmp1 := range w.Items {
		if err = w.Items[tmp1].Deserialize(rr); err != nil {
			return
		}
	}
	return
}

func (w *WindowProperty) Id() int { return 21 }
func (w *WindowProperty) Write(ww io.Writer) (err error) {
	var tmp [2]byte
	tmp[0] = byte(w.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(w.Property >> 8)
	tmp[1] = byte(w.Property >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(w.Value >> 8)
	tmp[1] = byte(w.Value >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	return
}
func (w *WindowProperty) Read(rr io.Reader) (err error) {
	var tmp [2]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.ID = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	w.Property = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	w.Value = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	return
}

func (w *WindowSetSlot) Id() int { return 22 }
func (w *WindowSetSlot) Write(ww io.Writer) (err error) {
	var tmp [2]byte
	tmp[0] = byte(w.ID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(w.Slot >> 8)
	tmp[1] = byte(w.Slot >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	if err = w.ItemStack.Serialize(ww); err != nil {
		return
	}
	return
}
func (w *WindowSetSlot) Read(rr io.Reader) (err error) {
	var tmp [2]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	w.ID = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	w.Slot = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if err = w.ItemStack.Deserialize(rr); err != nil {
		return
	}
	return
}

func (s *SetCooldown) Id() int { return 23 }
func (s *SetCooldown) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, s.ItemID); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, s.Ticks); err != nil {
		return
	}
	return
}
func (s *SetCooldown) Read(rr io.Reader) (err error) {
	if s.ItemID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if s.Ticks, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (p *PluginMessageClientbound) Id() int { return 24 }
func (p *PluginMessageClientbound) Write(ww io.Writer) (err error) {
	if err = lib.WriteString(ww, p.Channel); err != nil {
		return
	}
	if _, err = ww.Write(p.Data); err != nil {
		return
	}
	return
}
func (p *PluginMessageClientbound) Read(rr io.Reader) (err error) {
	if p.Channel, err = lib.ReadString(rr); err != nil {
		return
	}
	if p.Data, err = ioutil.ReadAll(rr); err != nil {
		return
	}
	return
}

func (s *SoundEffect) Id() int { return 25 }
func (s *SoundEffect) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	if err = lib.WriteString(ww, s.Name); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, s.Catargory); err != nil {
		return
	}
	tmp[0] = byte(s.X >> 24)
	tmp[1] = byte(s.X >> 16)
	tmp[2] = byte(s.X >> 8)
	tmp[3] = byte(s.X >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(s.Y >> 24)
	tmp[1] = byte(s.Y >> 16)
	tmp[2] = byte(s.Y >> 8)
	tmp[3] = byte(s.Y >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(s.Z >> 24)
	tmp[1] = byte(s.Z >> 16)
	tmp[2] = byte(s.Z >> 8)
	tmp[3] = byte(s.Z >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp0 := math.Float32bits(s.Volume)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp1 := math.Float32bits(s.Pitch)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (s *SoundEffect) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if s.Name, err = lib.ReadString(rr); err != nil {
		return
	}
	if s.Catargory, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	s.X = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	s.Y = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	s.Z = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	s.Volume = math.Float32frombits(tmp0)
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	s.Pitch = math.Float32frombits(tmp1)
	return
}

func (d *Disconnect) Id() int { return 26 }
func (d *Disconnect) Write(ww io.Writer) (err error) {
	var tmp0 []byte
	if tmp0, err = json.Marshal(&d.Reason); err != nil {
		return
	}
	tmp1 := string(tmp0)
	if err = lib.WriteString(ww, tmp1); err != nil {
		return
	}
	return
}
func (d *Disconnect) Read(rr io.Reader) (err error) {
	var tmp0 string
	if tmp0, err = lib.ReadString(rr); err != nil {
		return err
	}
	if err = json.Unmarshal([]byte(tmp0), &d.Reason); err != nil {
		return
	}
	return
}

func (e *EntityAction) Id() int { return 27 }
func (e *EntityAction) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(e.EntityID >> 24)
	tmp[1] = byte(e.EntityID >> 16)
	tmp[2] = byte(e.EntityID >> 8)
	tmp[3] = byte(e.EntityID >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(e.ActionID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (e *EntityAction) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	e.EntityID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.ActionID = (byte(tmp[0]) << 0)
	return
}

func (e *Explosion) Id() int { return 28 }
func (e *Explosion) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp0 := math.Float32bits(e.X)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp1 := math.Float32bits(e.Y)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp2 := math.Float32bits(e.Z)
	tmp[0] = byte(tmp2 >> 24)
	tmp[1] = byte(tmp2 >> 16)
	tmp[2] = byte(tmp2 >> 8)
	tmp[3] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp3 := math.Float32bits(e.Radius)
	tmp[0] = byte(tmp3 >> 24)
	tmp[1] = byte(tmp3 >> 16)
	tmp[2] = byte(tmp3 >> 8)
	tmp[3] = byte(tmp3 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(int32(len(e.Records)) >> 24)
	tmp[1] = byte(int32(len(e.Records)) >> 16)
	tmp[2] = byte(int32(len(e.Records)) >> 8)
	tmp[3] = byte(int32(len(e.Records)) >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	for tmp4 := range e.Records {
		tmp[0] = byte(e.Records[tmp4].X >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(e.Records[tmp4].Y >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(e.Records[tmp4].Z >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
	}
	tmp5 := math.Float32bits(e.VelocityX)
	tmp[0] = byte(tmp5 >> 24)
	tmp[1] = byte(tmp5 >> 16)
	tmp[2] = byte(tmp5 >> 8)
	tmp[3] = byte(tmp5 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp6 := math.Float32bits(e.VelocityY)
	tmp[0] = byte(tmp6 >> 24)
	tmp[1] = byte(tmp6 >> 16)
	tmp[2] = byte(tmp6 >> 8)
	tmp[3] = byte(tmp6 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp7 := math.Float32bits(e.VelocityZ)
	tmp[0] = byte(tmp7 >> 24)
	tmp[1] = byte(tmp7 >> 16)
	tmp[2] = byte(tmp7 >> 8)
	tmp[3] = byte(tmp7 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (e *Explosion) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.X = math.Float32frombits(tmp0)
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.Y = math.Float32frombits(tmp1)
	var tmp2 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp2 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.Z = math.Float32frombits(tmp2)
	var tmp3 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp3 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.Radius = math.Float32frombits(tmp3)
	var tmp4 int32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp4 = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if tmp4 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp4, math.MaxInt16)
	}
	if tmp4 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp4)
	}
	e.Records = make([]ExplosionRecord, tmp4)
	for tmp5 := range e.Records {
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		e.Records[tmp5].X = int8((uint8(tmp[0]) << 0))
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		e.Records[tmp5].Y = int8((uint8(tmp[0]) << 0))
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		e.Records[tmp5].Z = int8((uint8(tmp[0]) << 0))
	}
	var tmp6 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp6 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.VelocityX = math.Float32frombits(tmp6)
	var tmp7 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp7 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.VelocityY = math.Float32frombits(tmp7)
	var tmp8 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp8 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	e.VelocityZ = math.Float32frombits(tmp8)
	return
}

func (c *ChunkUnload) Id() int { return 29 }
func (c *ChunkUnload) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(c.X >> 24)
	tmp[1] = byte(c.X >> 16)
	tmp[2] = byte(c.X >> 8)
	tmp[3] = byte(c.X >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(c.Z >> 24)
	tmp[1] = byte(c.Z >> 16)
	tmp[2] = byte(c.Z >> 8)
	tmp[3] = byte(c.Z >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (c *ChunkUnload) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	c.X = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	c.Z = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	return
}

func (c *ChangeGameState) Id() int { return 30 }
func (c *ChangeGameState) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(c.Reason >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp0 := math.Float32bits(c.Value)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (c *ChangeGameState) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	c.Reason = (byte(tmp[0]) << 0)
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	c.Value = math.Float32frombits(tmp0)
	return
}

func (k *KeepAliveClientbound) Id() int { return 31 }
func (k *KeepAliveClientbound) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, k.ID); err != nil {
		return
	}
	return
}
func (k *KeepAliveClientbound) Read(rr io.Reader) (err error) {
	if k.ID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (c *ChunkData) Id() int { return 32 }
func (c *ChunkData) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(c.ChunkX >> 24)
	tmp[1] = byte(c.ChunkX >> 16)
	tmp[2] = byte(c.ChunkX >> 8)
	tmp[3] = byte(c.ChunkX >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(c.ChunkZ >> 24)
	tmp[1] = byte(c.ChunkZ >> 16)
	tmp[2] = byte(c.ChunkZ >> 8)
	tmp[3] = byte(c.ChunkZ >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = lib.WriteBool(ww, c.New); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, c.BitMask); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, lib.VarInt(len(c.Data))); err != nil {
		return
	}
	if _, err = ww.Write(c.Data); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, lib.VarInt(len(c.BlockEntities))); err != nil {
		return
	}
	for tmp0 := range c.BlockEntities {
		if err = lib.WriteNBT(ww, c.BlockEntities[tmp0].NBT); err != nil {
			return
		}
	}
	return
}
func (c *ChunkData) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	c.ChunkX = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	c.ChunkZ = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if c.New, err = lib.ReadBool(rr); err != nil {
		return
	}
	if c.BitMask, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 lib.VarInt
	if tmp0, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	c.Data = make([]byte, tmp0)
	if _, err = rr.Read(c.Data); err != nil {
		return
	}
	var tmp1 lib.VarInt
	if tmp1, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if tmp1 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp1, math.MaxInt16)
	}
	if tmp1 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp1)
	}
	c.BlockEntities = make([]BlockEntity, tmp1)
	for tmp2 := range c.BlockEntities {
		if c.BlockEntities[tmp2].NBT, err = lib.ReadNBT(rr); err != nil {
			return
		}
	}
	return
}

func (e *Effect) Id() int { return 33 }
func (e *Effect) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(e.EffectID >> 24)
	tmp[1] = byte(e.EffectID >> 16)
	tmp[2] = byte(e.EffectID >> 8)
	tmp[3] = byte(e.EffectID >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(e.Location >> 56)
	tmp[1] = byte(e.Location >> 48)
	tmp[2] = byte(e.Location >> 40)
	tmp[3] = byte(e.Location >> 32)
	tmp[4] = byte(e.Location >> 24)
	tmp[5] = byte(e.Location >> 16)
	tmp[6] = byte(e.Location >> 8)
	tmp[7] = byte(e.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(e.Data >> 24)
	tmp[1] = byte(e.Data >> 16)
	tmp[2] = byte(e.Data >> 8)
	tmp[3] = byte(e.Data >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = lib.WriteBool(ww, e.DisableRelative); err != nil {
		return
	}
	return
}
func (e *Effect) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	e.EffectID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	e.Location = (lib.Position(tmp[7]) << 0) | (lib.Position(tmp[6]) << 8) | (lib.Position(tmp[5]) << 16) | (lib.Position(tmp[4]) << 24) | (lib.Position(tmp[3]) << 32) | (lib.Position(tmp[2]) << 40) | (lib.Position(tmp[1]) << 48) | (lib.Position(tmp[0]) << 56)
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	e.Data = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if e.DisableRelative, err = lib.ReadBool(rr); err != nil {
		return
	}
	return
}

func (p *Particle) Id() int { return 34 }
func (p *Particle) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(p.ParticleID >> 24)
	tmp[1] = byte(p.ParticleID >> 16)
	tmp[2] = byte(p.ParticleID >> 8)
	tmp[3] = byte(p.ParticleID >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = lib.WriteBool(ww, p.LongDistance); err != nil {
		return
	}
	tmp0 := math.Float32bits(p.X)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp1 := math.Float32bits(p.Y)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp2 := math.Float32bits(p.Z)
	tmp[0] = byte(tmp2 >> 24)
	tmp[1] = byte(tmp2 >> 16)
	tmp[2] = byte(tmp2 >> 8)
	tmp[3] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp3 := math.Float32bits(p.OffsetX)
	tmp[0] = byte(tmp3 >> 24)
	tmp[1] = byte(tmp3 >> 16)
	tmp[2] = byte(tmp3 >> 8)
	tmp[3] = byte(tmp3 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp4 := math.Float32bits(p.OffsetY)
	tmp[0] = byte(tmp4 >> 24)
	tmp[1] = byte(tmp4 >> 16)
	tmp[2] = byte(tmp4 >> 8)
	tmp[3] = byte(tmp4 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp5 := math.Float32bits(p.OffsetZ)
	tmp[0] = byte(tmp5 >> 24)
	tmp[1] = byte(tmp5 >> 16)
	tmp[2] = byte(tmp5 >> 8)
	tmp[3] = byte(tmp5 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp6 := math.Float32bits(p.PData)
	tmp[0] = byte(tmp6 >> 24)
	tmp[1] = byte(tmp6 >> 16)
	tmp[2] = byte(tmp6 >> 8)
	tmp[3] = byte(tmp6 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(p.Count >> 24)
	tmp[1] = byte(p.Count >> 16)
	tmp[2] = byte(p.Count >> 8)
	tmp[3] = byte(p.Count >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	for tmp7 := range p.Data {
		if err = lib.WriteVarInt(ww, p.Data[tmp7]); err != nil {
			return
		}
	}
	return
}
func (p *Particle) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	p.ParticleID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if p.LongDistance, err = lib.ReadBool(rr); err != nil {
		return
	}
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.X = math.Float32frombits(tmp0)
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.Y = math.Float32frombits(tmp1)
	var tmp2 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp2 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.Z = math.Float32frombits(tmp2)
	var tmp3 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp3 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.OffsetX = math.Float32frombits(tmp3)
	var tmp4 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp4 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.OffsetY = math.Float32frombits(tmp4)
	var tmp5 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp5 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.OffsetZ = math.Float32frombits(tmp5)
	var tmp6 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp6 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.PData = math.Float32frombits(tmp6)
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	p.Count = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	tmp7 := particleDataLength(p)
	if tmp7 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp7, math.MaxInt16)
	}
	if tmp7 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp7)
	}
	p.Data = make([]lib.VarInt, tmp7)
	for tmp8 := range p.Data {
		if p.Data[tmp8], err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (j *JoinGame) Id() int { return 35 }
func (j *JoinGame) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(j.EntityID >> 24)
	tmp[1] = byte(j.EntityID >> 16)
	tmp[2] = byte(j.EntityID >> 8)
	tmp[3] = byte(j.EntityID >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(j.Gamemode >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(j.Dimension >> 24)
	tmp[1] = byte(j.Dimension >> 16)
	tmp[2] = byte(j.Dimension >> 8)
	tmp[3] = byte(j.Dimension >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(j.Difficulty >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(j.MaxPlayers >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteString(ww, j.LevelType); err != nil {
		return
	}
	if err = lib.WriteBool(ww, j.ReducedDebugInfo); err != nil {
		return
	}
	return
}
func (j *JoinGame) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	j.EntityID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	j.Gamemode = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	j.Dimension = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	j.Difficulty = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	j.MaxPlayers = (byte(tmp[0]) << 0)
	if j.LevelType, err = lib.ReadString(rr); err != nil {
		return
	}
	if j.ReducedDebugInfo, err = lib.ReadBool(rr); err != nil {
		return
	}
	return
}

func (m *Maps) Id() int { return 36 }
func (m *Maps) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = lib.WriteVarInt(ww, m.ItemDamage); err != nil {
		return
	}
	tmp[0] = byte(m.Scale >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteBool(ww, m.TrackingPosition); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, lib.VarInt(len(m.Icons))); err != nil {
		return
	}
	for tmp0 := range m.Icons {
		tmp[0] = byte(m.Icons[tmp0].DirectionType >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(m.Icons[tmp0].X >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(m.Icons[tmp0].Z >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
	}
	tmp[0] = byte(m.Columns >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if m.Columns > 0 {
		tmp[0] = byte(m.Rows >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(m.X >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		tmp[0] = byte(m.Z >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		if err = lib.WriteVarInt(ww, lib.VarInt(len(m.Data))); err != nil {
			return
		}
		if _, err = ww.Write(m.Data); err != nil {
			return
		}
	}
	return
}
func (m *Maps) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if m.ItemDamage, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	m.Scale = int8((uint8(tmp[0]) << 0))
	if m.TrackingPosition, err = lib.ReadBool(rr); err != nil {
		return
	}
	var tmp0 lib.VarInt
	if tmp0, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	m.Icons = make([]MapIcon, tmp0)
	for tmp1 := range m.Icons {
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Icons[tmp1].DirectionType = int8((uint8(tmp[0]) << 0))
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Icons[tmp1].X = int8((uint8(tmp[0]) << 0))
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Icons[tmp1].Z = int8((uint8(tmp[0]) << 0))
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	m.Columns = (byte(tmp[0]) << 0)
	if m.Columns > 0 {
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Rows = (byte(tmp[0]) << 0)
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.X = (byte(tmp[0]) << 0)
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		m.Z = (byte(tmp[0]) << 0)
		var tmp2 lib.VarInt
		if tmp2, err = lib.ReadVarInt(rr); err != nil {
			return
		}
		if tmp2 > math.MaxInt16 {
			return fmt.Errorf("array larger than max value: %d > %d", tmp2, math.MaxInt16)
		}
		if tmp2 < 0 {
			return fmt.Errorf("negative array size: %d < 0", tmp2)
		}
		m.Data = make([]byte, tmp2)
		if _, err = rr.Read(m.Data); err != nil {
			return
		}
	}
	return
}

func (e *EntityMove) Id() int { return 37 }
func (e *EntityMove) Write(ww io.Writer) (err error) {
	var tmp [2]byte
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaX >> 8)
	tmp[1] = byte(e.DeltaX >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaY >> 8)
	tmp[1] = byte(e.DeltaY >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaZ >> 8)
	tmp[1] = byte(e.DeltaZ >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	if err = lib.WriteBool(ww, e.OnGround); err != nil {
		return
	}
	return
}
func (e *EntityMove) Read(rr io.Reader) (err error) {
	var tmp [2]byte
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaX = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaY = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaZ = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if e.OnGround, err = lib.ReadBool(rr); err != nil {
		return
	}
	return
}

func (e *EntityLookAndMove) Id() int { return 38 }
func (e *EntityLookAndMove) Write(ww io.Writer) (err error) {
	var tmp [2]byte
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaX >> 8)
	tmp[1] = byte(e.DeltaX >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaY >> 8)
	tmp[1] = byte(e.DeltaY >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.DeltaZ >> 8)
	tmp[1] = byte(e.DeltaZ >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(e.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteBool(ww, e.OnGround); err != nil {
		return
	}
	return
}
func (e *EntityLookAndMove) Read(rr io.Reader) (err error) {
	var tmp [2]byte
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaX = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaY = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.DeltaZ = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Pitch = int8((uint8(tmp[0]) << 0))
	if e.OnGround, err = lib.ReadBool(rr); err != nil {
		return
	}
	return
}

func (e *EntityLook) Id() int { return 39 }
func (e *EntityLook) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(e.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteBool(ww, e.OnGround); err != nil {
		return
	}
	return
}
func (e *EntityLook) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Pitch = int8((uint8(tmp[0]) << 0))
	if e.OnGround, err = lib.ReadBool(rr); err != nil {
		return
	}
	return
}

func (e *Entity) Id() int { return 40 }
func (e *Entity) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	return
}
func (e *Entity) Read(rr io.Reader) (err error) {
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (v *VehicleMove) Id() int { return 41 }
func (v *VehicleMove) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(v.X >> 56)
	tmp[1] = byte(v.X >> 48)
	tmp[2] = byte(v.X >> 40)
	tmp[3] = byte(v.X >> 32)
	tmp[4] = byte(v.X >> 24)
	tmp[5] = byte(v.X >> 16)
	tmp[6] = byte(v.X >> 8)
	tmp[7] = byte(v.X >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(v.Y >> 56)
	tmp[1] = byte(v.Y >> 48)
	tmp[2] = byte(v.Y >> 40)
	tmp[3] = byte(v.Y >> 32)
	tmp[4] = byte(v.Y >> 24)
	tmp[5] = byte(v.Y >> 16)
	tmp[6] = byte(v.Y >> 8)
	tmp[7] = byte(v.Y >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(v.Z >> 56)
	tmp[1] = byte(v.Z >> 48)
	tmp[2] = byte(v.Z >> 40)
	tmp[3] = byte(v.Z >> 32)
	tmp[4] = byte(v.Z >> 24)
	tmp[5] = byte(v.Z >> 16)
	tmp[6] = byte(v.Z >> 8)
	tmp[7] = byte(v.Z >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp0 := math.Float32bits(v.Yaw)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp1 := math.Float32bits(v.Pitch)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (v *VehicleMove) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	v.X = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	v.Y = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	v.Z = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	v.Yaw = math.Float32frombits(tmp0)
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	v.Pitch = math.Float32frombits(tmp1)
	return
}

func (s *SignEditorOpen) Id() int { return 42 }
func (s *SignEditorOpen) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(s.Location >> 56)
	tmp[1] = byte(s.Location >> 48)
	tmp[2] = byte(s.Location >> 40)
	tmp[3] = byte(s.Location >> 32)
	tmp[4] = byte(s.Location >> 24)
	tmp[5] = byte(s.Location >> 16)
	tmp[6] = byte(s.Location >> 8)
	tmp[7] = byte(s.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	return
}
func (s *SignEditorOpen) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.Location = (lib.Position(tmp[7]) << 0) | (lib.Position(tmp[6]) << 8) | (lib.Position(tmp[5]) << 16) | (lib.Position(tmp[4]) << 24) | (lib.Position(tmp[3]) << 32) | (lib.Position(tmp[2]) << 40) | (lib.Position(tmp[1]) << 48) | (lib.Position(tmp[0]) << 56)
	return
}

func (p *PlayerAbilities) Id() int { return 43 }
func (p *PlayerAbilities) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(p.Flags >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp0 := math.Float32bits(p.FlyingSpeed)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp1 := math.Float32bits(p.WalkingSpeed)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (p *PlayerAbilities) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	p.Flags = (byte(tmp[0]) << 0)
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.FlyingSpeed = math.Float32frombits(tmp0)
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	p.WalkingSpeed = math.Float32frombits(tmp1)
	return
}

func (c *CombatEvent) Id() int { return 44 }
func (c *CombatEvent) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	if err = lib.WriteVarInt(ww, c.Event); err != nil {
		return
	}
	if c.Event == 1 {
		if err = lib.WriteVarInt(ww, c.Duration); err != nil {
			return
		}
	}
	if c.Event == 2 {
		if err = lib.WriteVarInt(ww, c.PlayerID); err != nil {
			return
		}
	}
	if c.Event == 1 || c.Event == 2 {
		tmp[0] = byte(c.EntityID >> 24)
		tmp[1] = byte(c.EntityID >> 16)
		tmp[2] = byte(c.EntityID >> 8)
		tmp[3] = byte(c.EntityID >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
	}
	if c.Event == 2 {
		var tmp0 []byte
		if tmp0, err = json.Marshal(&c.Message); err != nil {
			return
		}
		tmp1 := string(tmp0)
		if err = lib.WriteString(ww, tmp1); err != nil {
			return
		}
	}
	return
}
func (c *CombatEvent) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if c.Event, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if c.Event == 1 {
		if c.Duration, err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	if c.Event == 2 {
		if c.PlayerID, err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	if c.Event == 1 || c.Event == 2 {
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		c.EntityID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	}
	if c.Event == 2 {
		var tmp0 string
		if tmp0, err = lib.ReadString(rr); err != nil {
			return err
		}
		if err = json.Unmarshal([]byte(tmp0), &c.Message); err != nil {
			return
		}
	}
	return
}

func (p *PlayerInfo) Id() int { return 45 }
func (p *PlayerInfo) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, p.Action); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, lib.VarInt(len(p.Players))); err != nil {
		return
	}
	for tmp0 := range p.Players {
		if err = p.Players[tmp0].UUID.Serialize(ww); err != nil {
			return
		}
		if p.Action == 0 {
			if err = lib.WriteString(ww, p.Players[tmp0].Name); err != nil {
				return
			}
			if err = lib.WriteVarInt(ww, lib.VarInt(len(p.Players[tmp0].Properties))); err != nil {
				return
			}
			for tmp1 := range p.Players[tmp0].Properties {
				if err = lib.WriteString(ww, p.Players[tmp0].Properties[tmp1].Name); err != nil {
					return
				}
				if err = lib.WriteString(ww, p.Players[tmp0].Properties[tmp1].Value); err != nil {
					return
				}
				if err = lib.WriteBool(ww, p.Players[tmp0].Properties[tmp1].IsSigned); err != nil {
					return
				}
				if p.Players[tmp0].Properties[tmp1].IsSigned == true {
					if err = lib.WriteString(ww, p.Players[tmp0].Properties[tmp1].Signature); err != nil {
						return
					}
				}
			}
		}
		if p.Action == 0 || p.Action == 1 {
			if err = lib.WriteVarInt(ww, p.Players[tmp0].GameMode); err != nil {
				return
			}
		}
		if p.Action == 0 || p.Action == 2 {
			if err = lib.WriteVarInt(ww, p.Players[tmp0].Ping); err != nil {
				return
			}
		}
		if p.Action == 0 || p.Action == 3 {
			if err = lib.WriteBool(ww, p.Players[tmp0].HasDisplay); err != nil {
				return
			}
		}
		if p.Players[tmp0].HasDisplay == true {
			var tmp2 []byte
			if tmp2, err = json.Marshal(&p.Players[tmp0].DisplayName); err != nil {
				return
			}
			tmp3 := string(tmp2)
			if err = lib.WriteString(ww, tmp3); err != nil {
				return
			}
		}
	}
	return
}
func (p *PlayerInfo) Read(rr io.Reader) (err error) {
	if p.Action, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 lib.VarInt
	if tmp0, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	p.Players = make([]PlayerDetail, tmp0)
	for tmp1 := range p.Players {
		if err = p.Players[tmp1].UUID.Deserialize(rr); err != nil {
			return
		}
		if p.Action == 0 {
			if p.Players[tmp1].Name, err = lib.ReadString(rr); err != nil {
				return
			}
			var tmp2 lib.VarInt
			if tmp2, err = lib.ReadVarInt(rr); err != nil {
				return
			}
			if tmp2 > math.MaxInt16 {
				return fmt.Errorf("array larger than max value: %d > %d", tmp2, math.MaxInt16)
			}
			if tmp2 < 0 {
				return fmt.Errorf("negative array size: %d < 0", tmp2)
			}
			p.Players[tmp1].Properties = make([]PlayerProperty, tmp2)
			for tmp3 := range p.Players[tmp1].Properties {
				if p.Players[tmp1].Properties[tmp3].Name, err = lib.ReadString(rr); err != nil {
					return
				}
				if p.Players[tmp1].Properties[tmp3].Value, err = lib.ReadString(rr); err != nil {
					return
				}
				if p.Players[tmp1].Properties[tmp3].IsSigned, err = lib.ReadBool(rr); err != nil {
					return
				}
				if p.Players[tmp1].Properties[tmp3].IsSigned == true {
					if p.Players[tmp1].Properties[tmp3].Signature, err = lib.ReadString(rr); err != nil {
						return
					}
				}
			}
		}
		if p.Action == 0 || p.Action == 1 {
			if p.Players[tmp1].GameMode, err = lib.ReadVarInt(rr); err != nil {
				return
			}
		}
		if p.Action == 0 || p.Action == 2 {
			if p.Players[tmp1].Ping, err = lib.ReadVarInt(rr); err != nil {
				return
			}
		}
		if p.Action == 0 || p.Action == 3 {
			if p.Players[tmp1].HasDisplay, err = lib.ReadBool(rr); err != nil {
				return
			}
		}
		if p.Players[tmp1].HasDisplay == true {
			var tmp4 string
			if tmp4, err = lib.ReadString(rr); err != nil {
				return err
			}
			if err = json.Unmarshal([]byte(tmp4), &p.Players[tmp1].DisplayName); err != nil {
				return
			}
		}
	}
	return
}

func (t *TeleportPlayer) Id() int { return 46 }
func (t *TeleportPlayer) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp0 := math.Float64bits(t.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(t.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(t.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp3 := math.Float32bits(t.Yaw)
	tmp[0] = byte(tmp3 >> 24)
	tmp[1] = byte(tmp3 >> 16)
	tmp[2] = byte(tmp3 >> 8)
	tmp[3] = byte(tmp3 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp4 := math.Float32bits(t.Pitch)
	tmp[0] = byte(tmp4 >> 24)
	tmp[1] = byte(tmp4 >> 16)
	tmp[2] = byte(tmp4 >> 8)
	tmp[3] = byte(tmp4 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(t.Flags >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, t.TPID); err != nil {
		return
	}
	return
}
func (t *TeleportPlayer) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	t.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	t.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	t.Z = math.Float64frombits(tmp2)
	var tmp3 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp3 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	t.Yaw = math.Float32frombits(tmp3)
	var tmp4 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp4 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	t.Pitch = math.Float32frombits(tmp4)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	t.Flags = (byte(tmp[0]) << 0)
	if t.TPID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (e *EntityUsedBed) Id() int { return 47 }
func (e *EntityUsedBed) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.Location >> 56)
	tmp[1] = byte(e.Location >> 48)
	tmp[2] = byte(e.Location >> 40)
	tmp[3] = byte(e.Location >> 32)
	tmp[4] = byte(e.Location >> 24)
	tmp[5] = byte(e.Location >> 16)
	tmp[6] = byte(e.Location >> 8)
	tmp[7] = byte(e.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	return
}
func (e *EntityUsedBed) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	e.Location = (lib.Position(tmp[7]) << 0) | (lib.Position(tmp[6]) << 8) | (lib.Position(tmp[5]) << 16) | (lib.Position(tmp[4]) << 24) | (lib.Position(tmp[3]) << 32) | (lib.Position(tmp[2]) << 40) | (lib.Position(tmp[1]) << 48) | (lib.Position(tmp[0]) << 56)
	return
}

func (e *EntityDestroy) Id() int { return 48 }
func (e *EntityDestroy) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, lib.VarInt(len(e.EntityIDs))); err != nil {
		return
	}
	for tmp0 := range e.EntityIDs {
		if err = lib.WriteVarInt(ww, e.EntityIDs[tmp0]); err != nil {
			return
		}
	}
	return
}
func (e *EntityDestroy) Read(rr io.Reader) (err error) {
	var tmp0 lib.VarInt
	if tmp0, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	e.EntityIDs = make([]lib.VarInt, tmp0)
	for tmp1 := range e.EntityIDs {
		if e.EntityIDs[tmp1], err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (e *EntityRemoveEffect) Id() int { return 49 }
func (e *EntityRemoveEffect) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.EffectID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (e *EntityRemoveEffect) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.EffectID = int8((uint8(tmp[0]) << 0))
	return
}

func (r *ResourcePackSend) Id() int { return 50 }
func (r *ResourcePackSend) Write(ww io.Writer) (err error) {
	if err = lib.WriteString(ww, r.URL); err != nil {
		return
	}
	if err = lib.WriteString(ww, r.Hash); err != nil {
		return
	}
	return
}
func (r *ResourcePackSend) Read(rr io.Reader) (err error) {
	if r.URL, err = lib.ReadString(rr); err != nil {
		return
	}
	if r.Hash, err = lib.ReadString(rr); err != nil {
		return
	}
	return
}

func (r *Respawn) Id() int { return 51 }
func (r *Respawn) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(r.Dimension >> 24)
	tmp[1] = byte(r.Dimension >> 16)
	tmp[2] = byte(r.Dimension >> 8)
	tmp[3] = byte(r.Dimension >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(r.Difficulty >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(r.Gamemode >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteString(ww, r.LevelType); err != nil {
		return
	}
	return
}
func (r *Respawn) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	r.Dimension = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	r.Difficulty = (byte(tmp[0]) << 0)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	r.Gamemode = (byte(tmp[0]) << 0)
	if r.LevelType, err = lib.ReadString(rr); err != nil {
		return
	}
	return
}

func (e *EntityHeadLook) Id() int { return 52 }
func (e *EntityHeadLook) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.HeadYaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (e *EntityHeadLook) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.HeadYaw = int8((uint8(tmp[0]) << 0))
	return
}

func (w *WorldBorder) Id() int { return 53 }
func (w *WorldBorder) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = lib.WriteVarInt(ww, w.Action); err != nil {
		return
	}
	if w.Action == 3 || w.Action == 1 {
		tmp0 := math.Float64bits(w.OldRadius)
		tmp[0] = byte(tmp0 >> 56)
		tmp[1] = byte(tmp0 >> 48)
		tmp[2] = byte(tmp0 >> 40)
		tmp[3] = byte(tmp0 >> 32)
		tmp[4] = byte(tmp0 >> 24)
		tmp[5] = byte(tmp0 >> 16)
		tmp[6] = byte(tmp0 >> 8)
		tmp[7] = byte(tmp0 >> 0)
		if _, err = ww.Write(tmp[:8]); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 1 || w.Action == 0 {
		tmp1 := math.Float64bits(w.NewRadius)
		tmp[0] = byte(tmp1 >> 56)
		tmp[1] = byte(tmp1 >> 48)
		tmp[2] = byte(tmp1 >> 40)
		tmp[3] = byte(tmp1 >> 32)
		tmp[4] = byte(tmp1 >> 24)
		tmp[5] = byte(tmp1 >> 16)
		tmp[6] = byte(tmp1 >> 8)
		tmp[7] = byte(tmp1 >> 0)
		if _, err = ww.Write(tmp[:8]); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 1 {
		if err = lib.WriteVarLong(ww, w.Speed); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 2 {
		tmp2 := math.Float64bits(w.X)
		tmp[0] = byte(tmp2 >> 56)
		tmp[1] = byte(tmp2 >> 48)
		tmp[2] = byte(tmp2 >> 40)
		tmp[3] = byte(tmp2 >> 32)
		tmp[4] = byte(tmp2 >> 24)
		tmp[5] = byte(tmp2 >> 16)
		tmp[6] = byte(tmp2 >> 8)
		tmp[7] = byte(tmp2 >> 0)
		if _, err = ww.Write(tmp[:8]); err != nil {
			return
		}
		tmp3 := math.Float64bits(w.Z)
		tmp[0] = byte(tmp3 >> 56)
		tmp[1] = byte(tmp3 >> 48)
		tmp[2] = byte(tmp3 >> 40)
		tmp[3] = byte(tmp3 >> 32)
		tmp[4] = byte(tmp3 >> 24)
		tmp[5] = byte(tmp3 >> 16)
		tmp[6] = byte(tmp3 >> 8)
		tmp[7] = byte(tmp3 >> 0)
		if _, err = ww.Write(tmp[:8]); err != nil {
			return
		}
	}
	if w.Action == 3 {
		if err = lib.WriteVarInt(ww, w.PortalBoundary); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 4 {
		if err = lib.WriteVarInt(ww, w.WarningTime); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 5 {
		if err = lib.WriteVarInt(ww, w.WarningBlocks); err != nil {
			return
		}
	}
	return
}
func (w *WorldBorder) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if w.Action, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if w.Action == 3 || w.Action == 1 {
		var tmp0 uint64
		if _, err = rr.Read(tmp[:8]); err != nil {
			return
		}
		tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
		w.OldRadius = math.Float64frombits(tmp0)
	}
	if w.Action == 3 || w.Action == 1 || w.Action == 0 {
		var tmp1 uint64
		if _, err = rr.Read(tmp[:8]); err != nil {
			return
		}
		tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
		w.NewRadius = math.Float64frombits(tmp1)
	}
	if w.Action == 3 || w.Action == 1 {
		if w.Speed, err = lib.ReadVarLong(rr); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 2 {
		var tmp2 uint64
		if _, err = rr.Read(tmp[:8]); err != nil {
			return
		}
		tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
		w.X = math.Float64frombits(tmp2)
		var tmp3 uint64
		if _, err = rr.Read(tmp[:8]); err != nil {
			return
		}
		tmp3 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
		w.Z = math.Float64frombits(tmp3)
	}
	if w.Action == 3 {
		if w.PortalBoundary, err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 4 {
		if w.WarningTime, err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	if w.Action == 3 || w.Action == 5 {
		if w.WarningBlocks, err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (c *Camera) Id() int { return 54 }
func (c *Camera) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, c.TargetID); err != nil {
		return
	}
	return
}
func (c *Camera) Read(rr io.Reader) (err error) {
	if c.TargetID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (s *SetCurrentHotbarSlot) Id() int { return 55 }
func (s *SetCurrentHotbarSlot) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	tmp[0] = byte(s.Slot >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	return
}
func (s *SetCurrentHotbarSlot) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Slot = (byte(tmp[0]) << 0)
	return
}

func (s *ScoreboardDisplay) Id() int { return 56 }
func (s *ScoreboardDisplay) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	tmp[0] = byte(s.Position >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteString(ww, s.Name); err != nil {
		return
	}
	return
}
func (s *ScoreboardDisplay) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Position = (byte(tmp[0]) << 0)
	if s.Name, err = lib.ReadString(rr); err != nil {
		return
	}
	return
}

func (e *EntityMetadata) Id() int { return 57 }
func (e *EntityMetadata) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	if err = lib.WriteMetadata(ww, e.Metadata); err != nil {
		return
	}
	return
}
func (e *EntityMetadata) Read(rr io.Reader) (err error) {
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if e.Metadata, err = lib.ReadMetadata(rr); err != nil {
		return
	}
	return
}

func (e *EntityAttach) Id() int { return 58 }
func (e *EntityAttach) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp[0] = byte(e.EntityID >> 24)
	tmp[1] = byte(e.EntityID >> 16)
	tmp[2] = byte(e.EntityID >> 8)
	tmp[3] = byte(e.EntityID >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(e.Vehicle >> 24)
	tmp[1] = byte(e.Vehicle >> 16)
	tmp[2] = byte(e.Vehicle >> 8)
	tmp[3] = byte(e.Vehicle >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = lib.WriteBool(ww, e.Leash); err != nil {
		return
	}
	return
}
func (e *EntityAttach) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	e.EntityID = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	e.Vehicle = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if e.Leash, err = lib.ReadBool(rr); err != nil {
		return
	}
	return
}

func (e *EntityVelocity) Id() int { return 59 }
func (e *EntityVelocity) Write(ww io.Writer) (err error) {
	var tmp [2]byte
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.VelocityX >> 8)
	tmp[1] = byte(e.VelocityX >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.VelocityY >> 8)
	tmp[1] = byte(e.VelocityY >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	tmp[0] = byte(e.VelocityZ >> 8)
	tmp[1] = byte(e.VelocityZ >> 0)
	if _, err = ww.Write(tmp[:2]); err != nil {
		return
	}
	return
}
func (e *EntityVelocity) Read(rr io.Reader) (err error) {
	var tmp [2]byte
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.VelocityX = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.VelocityY = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	if _, err = rr.Read(tmp[:2]); err != nil {
		return
	}
	e.VelocityZ = int16((uint16(tmp[1]) << 0) | (uint16(tmp[0]) << 8))
	return
}

func (e *EntityEquipment) Id() int { return 60 }
func (e *EntityEquipment) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, e.Slot); err != nil {
		return
	}
	if err = e.Item.Serialize(ww); err != nil {
		return
	}
	return
}
func (e *EntityEquipment) Read(rr io.Reader) (err error) {
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if e.Slot, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if err = e.Item.Deserialize(rr); err != nil {
		return
	}
	return
}

func (s *SetExperience) Id() int { return 61 }
func (s *SetExperience) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp0 := math.Float32bits(s.ExperienceBar)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, s.Level); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, s.TotalExperience); err != nil {
		return
	}
	return
}
func (s *SetExperience) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	s.ExperienceBar = math.Float32frombits(tmp0)
	if s.Level, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if s.TotalExperience, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (u *UpdateHealth) Id() int { return 62 }
func (u *UpdateHealth) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	tmp0 := math.Float32bits(u.Health)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, u.Food); err != nil {
		return
	}
	tmp1 := math.Float32bits(u.FoodSaturation)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (u *UpdateHealth) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	u.Health = math.Float32frombits(tmp0)
	if u.Food, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	u.FoodSaturation = math.Float32frombits(tmp1)
	return
}

func (s *ScoreboardObjective) Id() int { return 63 }
func (s *ScoreboardObjective) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = lib.WriteString(ww, s.Name); err != nil {
		return
	}
	tmp[0] = byte(s.Mode >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if s.Mode == 0 || s.Mode == 2 {
		if err = lib.WriteString(ww, s.Value); err != nil {
			return
		}
		if err = lib.WriteString(ww, s.Type); err != nil {
			return
		}
	}
	return
}
func (s *ScoreboardObjective) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if s.Name, err = lib.ReadString(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	s.Mode = (byte(tmp[0]) << 0)
	if s.Mode == 0 || s.Mode == 2 {
		if s.Value, err = lib.ReadString(rr); err != nil {
			return
		}
		if s.Type, err = lib.ReadString(rr); err != nil {
			return
		}
	}
	return
}

func (p *Passengers) Id() int { return 64 }
func (p *Passengers) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, p.ID); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, lib.VarInt(len(p.Passengers))); err != nil {
		return
	}
	for tmp0 := range p.Passengers {
		if err = lib.WriteVarInt(ww, p.Passengers[tmp0]); err != nil {
			return
		}
	}
	return
}
func (p *Passengers) Read(rr io.Reader) (err error) {
	if p.ID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 lib.VarInt
	if tmp0, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	p.Passengers = make([]lib.VarInt, tmp0)
	for tmp1 := range p.Passengers {
		if p.Passengers[tmp1], err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (t *Teams) Id() int { return 65 }
func (t *Teams) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = lib.WriteString(ww, t.Name); err != nil {
		return
	}
	tmp[0] = byte(t.Mode >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if t.Mode == 0 || t.Mode == 2 {
		if err = lib.WriteString(ww, t.DisplayName); err != nil {
			return
		}
		if err = lib.WriteString(ww, t.Prefix); err != nil {
			return
		}
		if err = lib.WriteString(ww, t.Suffix); err != nil {
			return
		}
		tmp[0] = byte(t.Flags >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
		if err = lib.WriteString(ww, t.NameTagVisibility); err != nil {
			return
		}
		if err = lib.WriteString(ww, t.CollisionRule); err != nil {
			return
		}
		tmp[0] = byte(t.Color >> 0)
		if _, err = ww.Write(tmp[:1]); err != nil {
			return
		}
	}
	if t.Mode == 0 || t.Mode == 3 || t.Mode == 4 {
		if err = lib.WriteVarInt(ww, lib.VarInt(len(t.Players))); err != nil {
			return
		}
		for tmp0 := range t.Players {
			if err = lib.WriteString(ww, t.Players[tmp0]); err != nil {
				return
			}
		}
	}
	return
}
func (t *Teams) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if t.Name, err = lib.ReadString(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	t.Mode = (byte(tmp[0]) << 0)
	if t.Mode == 0 || t.Mode == 2 {
		if t.DisplayName, err = lib.ReadString(rr); err != nil {
			return
		}
		if t.Prefix, err = lib.ReadString(rr); err != nil {
			return
		}
		if t.Suffix, err = lib.ReadString(rr); err != nil {
			return
		}
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		t.Flags = (byte(tmp[0]) << 0)
		if t.NameTagVisibility, err = lib.ReadString(rr); err != nil {
			return
		}
		if t.CollisionRule, err = lib.ReadString(rr); err != nil {
			return
		}
		if _, err = rr.Read(tmp[:1]); err != nil {
			return
		}
		t.Color = (byte(tmp[0]) << 0)
	}
	if t.Mode == 0 || t.Mode == 3 || t.Mode == 4 {
		var tmp0 lib.VarInt
		if tmp0, err = lib.ReadVarInt(rr); err != nil {
			return
		}
		if tmp0 > math.MaxInt16 {
			return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
		}
		if tmp0 < 0 {
			return fmt.Errorf("negative array size: %d < 0", tmp0)
		}
		t.Players = make([]string, tmp0)
		for tmp1 := range t.Players {
			if t.Players[tmp1], err = lib.ReadString(rr); err != nil {
				return
			}
		}
	}
	return
}

func (u *UpdateScore) Id() int { return 66 }
func (u *UpdateScore) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = lib.WriteString(ww, u.Name); err != nil {
		return
	}
	tmp[0] = byte(u.Action >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteString(ww, u.ObjectName); err != nil {
		return
	}
	if u.Action != 1 {
		if err = lib.WriteVarInt(ww, u.Value); err != nil {
			return
		}
	}
	return
}
func (u *UpdateScore) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if u.Name, err = lib.ReadString(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	u.Action = (byte(tmp[0]) << 0)
	if u.ObjectName, err = lib.ReadString(rr); err != nil {
		return
	}
	if u.Action != 1 {
		if u.Value, err = lib.ReadVarInt(rr); err != nil {
			return
		}
	}
	return
}

func (s *SpawnPosition) Id() int { return 67 }
func (s *SpawnPosition) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(s.Location >> 56)
	tmp[1] = byte(s.Location >> 48)
	tmp[2] = byte(s.Location >> 40)
	tmp[3] = byte(s.Location >> 32)
	tmp[4] = byte(s.Location >> 24)
	tmp[5] = byte(s.Location >> 16)
	tmp[6] = byte(s.Location >> 8)
	tmp[7] = byte(s.Location >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	return
}
func (s *SpawnPosition) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	s.Location = (lib.Position(tmp[7]) << 0) | (lib.Position(tmp[6]) << 8) | (lib.Position(tmp[5]) << 16) | (lib.Position(tmp[4]) << 24) | (lib.Position(tmp[3]) << 32) | (lib.Position(tmp[2]) << 40) | (lib.Position(tmp[1]) << 48) | (lib.Position(tmp[0]) << 56)
	return
}

func (t *TimeUpdate) Id() int { return 68 }
func (t *TimeUpdate) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	tmp[0] = byte(t.WorldAge >> 56)
	tmp[1] = byte(t.WorldAge >> 48)
	tmp[2] = byte(t.WorldAge >> 40)
	tmp[3] = byte(t.WorldAge >> 32)
	tmp[4] = byte(t.WorldAge >> 24)
	tmp[5] = byte(t.WorldAge >> 16)
	tmp[6] = byte(t.WorldAge >> 8)
	tmp[7] = byte(t.WorldAge >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(t.TimeOfDay >> 56)
	tmp[1] = byte(t.TimeOfDay >> 48)
	tmp[2] = byte(t.TimeOfDay >> 40)
	tmp[3] = byte(t.TimeOfDay >> 32)
	tmp[4] = byte(t.TimeOfDay >> 24)
	tmp[5] = byte(t.TimeOfDay >> 16)
	tmp[6] = byte(t.TimeOfDay >> 8)
	tmp[7] = byte(t.TimeOfDay >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	return
}
func (t *TimeUpdate) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	t.WorldAge = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	t.TimeOfDay = int64((uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56))
	return
}

func (t *Title) Id() int { return 69 }
func (t *Title) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	if err = lib.WriteVarInt(ww, t.Action); err != nil {
		return
	}
	if t.Action == 0 {
		var tmp0 []byte
		if tmp0, err = json.Marshal(&t.Title); err != nil {
			return
		}
		tmp1 := string(tmp0)
		if err = lib.WriteString(ww, tmp1); err != nil {
			return
		}
	}
	if t.Action == 1 {
		var tmp2 []byte
		if tmp2, err = json.Marshal(&t.SubTitle); err != nil {
			return
		}
		tmp3 := string(tmp2)
		if err = lib.WriteString(ww, tmp3); err != nil {
			return
		}
	}
	if t.Action == 2 {
		tmp[0] = byte(t.FadeIn >> 24)
		tmp[1] = byte(t.FadeIn >> 16)
		tmp[2] = byte(t.FadeIn >> 8)
		tmp[3] = byte(t.FadeIn >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
		tmp[0] = byte(t.FadeStay >> 24)
		tmp[1] = byte(t.FadeStay >> 16)
		tmp[2] = byte(t.FadeStay >> 8)
		tmp[3] = byte(t.FadeStay >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
		tmp[0] = byte(t.FadeOut >> 24)
		tmp[1] = byte(t.FadeOut >> 16)
		tmp[2] = byte(t.FadeOut >> 8)
		tmp[3] = byte(t.FadeOut >> 0)
		if _, err = ww.Write(tmp[:4]); err != nil {
			return
		}
	}
	return
}
func (t *Title) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if t.Action, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if t.Action == 0 {
		var tmp0 string
		if tmp0, err = lib.ReadString(rr); err != nil {
			return err
		}
		if err = json.Unmarshal([]byte(tmp0), &t.Title); err != nil {
			return
		}
	}
	if t.Action == 1 {
		var tmp1 string
		if tmp1, err = lib.ReadString(rr); err != nil {
			return err
		}
		if err = json.Unmarshal([]byte(tmp1), &t.SubTitle); err != nil {
			return
		}
	}
	if t.Action == 2 {
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		t.FadeIn = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		t.FadeStay = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
		if _, err = rr.Read(tmp[:4]); err != nil {
			return
		}
		t.FadeOut = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	}
	return
}

func (h *HardSoundEffect) Id() int { return 70 }
func (h *HardSoundEffect) Write(ww io.Writer) (err error) {
	var tmp [4]byte
	if err = lib.WriteVarInt(ww, h.ID); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, h.Cat); err != nil {
		return
	}
	tmp[0] = byte(h.X >> 24)
	tmp[1] = byte(h.X >> 16)
	tmp[2] = byte(h.X >> 8)
	tmp[3] = byte(h.X >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(h.Y >> 24)
	tmp[1] = byte(h.Y >> 16)
	tmp[2] = byte(h.Y >> 8)
	tmp[3] = byte(h.Y >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp[0] = byte(h.Z >> 24)
	tmp[1] = byte(h.Z >> 16)
	tmp[2] = byte(h.Z >> 8)
	tmp[3] = byte(h.Z >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp0 := math.Float32bits(h.Vol)
	tmp[0] = byte(tmp0 >> 24)
	tmp[1] = byte(tmp0 >> 16)
	tmp[2] = byte(tmp0 >> 8)
	tmp[3] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	tmp1 := math.Float32bits(h.pitch)
	tmp[0] = byte(tmp1 >> 24)
	tmp[1] = byte(tmp1 >> 16)
	tmp[2] = byte(tmp1 >> 8)
	tmp[3] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	return
}
func (h *HardSoundEffect) Read(rr io.Reader) (err error) {
	var tmp [4]byte
	if h.ID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if h.Cat, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	h.X = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	h.Y = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	h.Z = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	var tmp0 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	h.Vol = math.Float32frombits(tmp0)
	var tmp1 uint32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp1 = (uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24)
	h.pitch = math.Float32frombits(tmp1)
	return
}

func (p *PlayerListHeaderFooter) Id() int { return 71 }
func (p *PlayerListHeaderFooter) Write(ww io.Writer) (err error) {
	var tmp0 []byte
	if tmp0, err = json.Marshal(&p.Header); err != nil {
		return
	}
	tmp1 := string(tmp0)
	if err = lib.WriteString(ww, tmp1); err != nil {
		return
	}
	var tmp2 []byte
	if tmp2, err = json.Marshal(&p.Footer); err != nil {
		return
	}
	tmp3 := string(tmp2)
	if err = lib.WriteString(ww, tmp3); err != nil {
		return
	}
	return
}
func (p *PlayerListHeaderFooter) Read(rr io.Reader) (err error) {
	var tmp0 string
	if tmp0, err = lib.ReadString(rr); err != nil {
		return err
	}
	if err = json.Unmarshal([]byte(tmp0), &p.Header); err != nil {
		return
	}
	var tmp1 string
	if tmp1, err = lib.ReadString(rr); err != nil {
		return err
	}
	if err = json.Unmarshal([]byte(tmp1), &p.Footer); err != nil {
		return
	}
	return
}

func (c *CollectItem) Id() int { return 72 }
func (c *CollectItem) Write(ww io.Writer) (err error) {
	if err = lib.WriteVarInt(ww, c.CollectedEntityID); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, c.CollectorEntityID); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, c.PickUpCount); err != nil {
		return
	}
	return
}
func (c *CollectItem) Read(rr io.Reader) (err error) {
	if c.CollectedEntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if c.CollectorEntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if c.PickUpCount, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	return
}

func (e *EntityTeleport) Id() int { return 73 }
func (e *EntityTeleport) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp0 := math.Float64bits(e.X)
	tmp[0] = byte(tmp0 >> 56)
	tmp[1] = byte(tmp0 >> 48)
	tmp[2] = byte(tmp0 >> 40)
	tmp[3] = byte(tmp0 >> 32)
	tmp[4] = byte(tmp0 >> 24)
	tmp[5] = byte(tmp0 >> 16)
	tmp[6] = byte(tmp0 >> 8)
	tmp[7] = byte(tmp0 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp1 := math.Float64bits(e.Y)
	tmp[0] = byte(tmp1 >> 56)
	tmp[1] = byte(tmp1 >> 48)
	tmp[2] = byte(tmp1 >> 40)
	tmp[3] = byte(tmp1 >> 32)
	tmp[4] = byte(tmp1 >> 24)
	tmp[5] = byte(tmp1 >> 16)
	tmp[6] = byte(tmp1 >> 8)
	tmp[7] = byte(tmp1 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp2 := math.Float64bits(e.Z)
	tmp[0] = byte(tmp2 >> 56)
	tmp[1] = byte(tmp2 >> 48)
	tmp[2] = byte(tmp2 >> 40)
	tmp[3] = byte(tmp2 >> 32)
	tmp[4] = byte(tmp2 >> 24)
	tmp[5] = byte(tmp2 >> 16)
	tmp[6] = byte(tmp2 >> 8)
	tmp[7] = byte(tmp2 >> 0)
	if _, err = ww.Write(tmp[:8]); err != nil {
		return
	}
	tmp[0] = byte(e.Yaw >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(e.Pitch >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteBool(ww, e.OnGround); err != nil {
		return
	}
	return
}
func (e *EntityTeleport) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp0 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	e.X = math.Float64frombits(tmp0)
	var tmp1 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp1 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	e.Y = math.Float64frombits(tmp1)
	var tmp2 uint64
	if _, err = rr.Read(tmp[:8]); err != nil {
		return
	}
	tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
	e.Z = math.Float64frombits(tmp2)
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Yaw = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Pitch = int8((uint8(tmp[0]) << 0))
	if e.OnGround, err = lib.ReadBool(rr); err != nil {
		return
	}
	return
}

func (e *EntityProperties) Id() int { return 74 }
func (e *EntityProperties) Write(ww io.Writer) (err error) {
	var tmp [8]byte
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(int32(len(e.Properties)) >> 24)
	tmp[1] = byte(int32(len(e.Properties)) >> 16)
	tmp[2] = byte(int32(len(e.Properties)) >> 8)
	tmp[3] = byte(int32(len(e.Properties)) >> 0)
	if _, err = ww.Write(tmp[:4]); err != nil {
		return
	}
	for tmp0 := range e.Properties {
		if err = lib.WriteString(ww, e.Properties[tmp0].Key); err != nil {
			return
		}
		tmp1 := math.Float64bits(e.Properties[tmp0].Value)
		tmp[0] = byte(tmp1 >> 56)
		tmp[1] = byte(tmp1 >> 48)
		tmp[2] = byte(tmp1 >> 40)
		tmp[3] = byte(tmp1 >> 32)
		tmp[4] = byte(tmp1 >> 24)
		tmp[5] = byte(tmp1 >> 16)
		tmp[6] = byte(tmp1 >> 8)
		tmp[7] = byte(tmp1 >> 0)
		if _, err = ww.Write(tmp[:8]); err != nil {
			return
		}
		if err = lib.WriteVarInt(ww, lib.VarInt(len(e.Properties[tmp0].Modifiers))); err != nil {
			return
		}
		for tmp2 := range e.Properties[tmp0].Modifiers {
			if err = e.Properties[tmp0].Modifiers[tmp2].UUID.Serialize(ww); err != nil {
				return
			}
			tmp3 := math.Float64bits(e.Properties[tmp0].Modifiers[tmp2].Amount)
			tmp[0] = byte(tmp3 >> 56)
			tmp[1] = byte(tmp3 >> 48)
			tmp[2] = byte(tmp3 >> 40)
			tmp[3] = byte(tmp3 >> 32)
			tmp[4] = byte(tmp3 >> 24)
			tmp[5] = byte(tmp3 >> 16)
			tmp[6] = byte(tmp3 >> 8)
			tmp[7] = byte(tmp3 >> 0)
			if _, err = ww.Write(tmp[:8]); err != nil {
				return
			}
			tmp[0] = byte(e.Properties[tmp0].Modifiers[tmp2].Operation >> 0)
			if _, err = ww.Write(tmp[:1]); err != nil {
				return
			}
		}
	}
	return
}
func (e *EntityProperties) Read(rr io.Reader) (err error) {
	var tmp [8]byte
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	var tmp0 int32
	if _, err = rr.Read(tmp[:4]); err != nil {
		return
	}
	tmp0 = int32((uint32(tmp[3]) << 0) | (uint32(tmp[2]) << 8) | (uint32(tmp[1]) << 16) | (uint32(tmp[0]) << 24))
	if tmp0 > math.MaxInt16 {
		return fmt.Errorf("array larger than max value: %d > %d", tmp0, math.MaxInt16)
	}
	if tmp0 < 0 {
		return fmt.Errorf("negative array size: %d < 0", tmp0)
	}
	e.Properties = make([]EntityProperty, tmp0)
	for tmp1 := range e.Properties {
		if e.Properties[tmp1].Key, err = lib.ReadString(rr); err != nil {
			return
		}
		var tmp2 uint64
		if _, err = rr.Read(tmp[:8]); err != nil {
			return
		}
		tmp2 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
		e.Properties[tmp1].Value = math.Float64frombits(tmp2)
		var tmp3 lib.VarInt
		if tmp3, err = lib.ReadVarInt(rr); err != nil {
			return
		}
		if tmp3 > math.MaxInt16 {
			return fmt.Errorf("array larger than max value: %d > %d", tmp3, math.MaxInt16)
		}
		if tmp3 < 0 {
			return fmt.Errorf("negative array size: %d < 0", tmp3)
		}
		e.Properties[tmp1].Modifiers = make([]PropertyModifier, tmp3)
		for tmp4 := range e.Properties[tmp1].Modifiers {
			if err = e.Properties[tmp1].Modifiers[tmp4].UUID.Deserialize(rr); err != nil {
				return
			}
			var tmp5 uint64
			if _, err = rr.Read(tmp[:8]); err != nil {
				return
			}
			tmp5 = (uint64(tmp[7]) << 0) | (uint64(tmp[6]) << 8) | (uint64(tmp[5]) << 16) | (uint64(tmp[4]) << 24) | (uint64(tmp[3]) << 32) | (uint64(tmp[2]) << 40) | (uint64(tmp[1]) << 48) | (uint64(tmp[0]) << 56)
			e.Properties[tmp1].Modifiers[tmp4].Amount = math.Float64frombits(tmp5)
			if _, err = rr.Read(tmp[:1]); err != nil {
				return
			}
			e.Properties[tmp1].Modifiers[tmp4].Operation = int8((uint8(tmp[0]) << 0))
		}
	}
	return
}

func (e *EntityEffect) Id() int { return 75 }
func (e *EntityEffect) Write(ww io.Writer) (err error) {
	var tmp [1]byte
	if err = lib.WriteVarInt(ww, e.EntityID); err != nil {
		return
	}
	tmp[0] = byte(e.EffectID >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	tmp[0] = byte(e.Amplifier >> 0)
	if _, err = ww.Write(tmp[:1]); err != nil {
		return
	}
	if err = lib.WriteVarInt(ww, e.Duration); err != nil {
		return
	}
	if err = lib.WriteBool(ww, e.HideParticles); err != nil {
		return
	}
	return
}
func (e *EntityEffect) Read(rr io.Reader) (err error) {
	var tmp [1]byte
	if e.EntityID, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.EffectID = int8((uint8(tmp[0]) << 0))
	if _, err = rr.Read(tmp[:1]); err != nil {
		return
	}
	e.Amplifier = int8((uint8(tmp[0]) << 0))
	if e.Duration, err = lib.ReadVarInt(rr); err != nil {
		return
	}
	if e.HideParticles, err = lib.ReadBool(rr); err != nil {
		return
	}
	return
}

func init() {
	packets[lib.Play][lib.Clientbound][0] = func() lib.Packet { return &SpawnObject{} }
	packets[lib.Play][lib.Clientbound][1] = func() lib.Packet { return &SpawnExperienceOrb{} }
	packets[lib.Play][lib.Clientbound][2] = func() lib.Packet { return &SpawnGlobalEntity{} }
	packets[lib.Play][lib.Clientbound][3] = func() lib.Packet { return &SpawnMob{} }
	packets[lib.Play][lib.Clientbound][4] = func() lib.Packet { return &SpawnPainting{} }
	packets[lib.Play][lib.Clientbound][5] = func() lib.Packet { return &SpawnPlayer{} }
	packets[lib.Play][lib.Clientbound][6] = func() lib.Packet { return &Animation{} }
	packets[lib.Play][lib.Clientbound][7] = func() lib.Packet { return &Statistics{} }
	packets[lib.Play][lib.Clientbound][8] = func() lib.Packet { return &BlockBreakAnimation{} }
	packets[lib.Play][lib.Clientbound][9] = func() lib.Packet { return &UpdateBlockEntity{} }
	packets[lib.Play][lib.Clientbound][10] = func() lib.Packet { return &BlockAction{} }
	packets[lib.Play][lib.Clientbound][11] = func() lib.Packet { return &BlockChange{} }
	packets[lib.Play][lib.Clientbound][12] = func() lib.Packet { return &BossBar{} }
	packets[lib.Play][lib.Clientbound][13] = func() lib.Packet { return &ServerDifficulty{} }
	packets[lib.Play][lib.Clientbound][14] = func() lib.Packet { return &TabCompleteReply{} }
	packets[lib.Play][lib.Clientbound][15] = func() lib.Packet { return &ServerMessage{} }
	packets[lib.Play][lib.Clientbound][16] = func() lib.Packet { return &MultiBlockChange{} }
	packets[lib.Play][lib.Clientbound][17] = func() lib.Packet { return &ConfirmTransaction{} }
	packets[lib.Play][lib.Clientbound][18] = func() lib.Packet { return &WindowClose{} }
	packets[lib.Play][lib.Clientbound][19] = func() lib.Packet { return &WindowOpen{} }
	packets[lib.Play][lib.Clientbound][20] = func() lib.Packet { return &WindowItems{} }
	packets[lib.Play][lib.Clientbound][21] = func() lib.Packet { return &WindowProperty{} }
	packets[lib.Play][lib.Clientbound][22] = func() lib.Packet { return &WindowSetSlot{} }
	packets[lib.Play][lib.Clientbound][23] = func() lib.Packet { return &SetCooldown{} }
	packets[lib.Play][lib.Clientbound][24] = func() lib.Packet { return &PluginMessageClientbound{} }
	packets[lib.Play][lib.Clientbound][25] = func() lib.Packet { return &SoundEffect{} }
	packets[lib.Play][lib.Clientbound][26] = func() lib.Packet { return &Disconnect{} }
	packets[lib.Play][lib.Clientbound][27] = func() lib.Packet { return &EntityAction{} }
	packets[lib.Play][lib.Clientbound][28] = func() lib.Packet { return &Explosion{} }
	packets[lib.Play][lib.Clientbound][29] = func() lib.Packet { return &ChunkUnload{} }
	packets[lib.Play][lib.Clientbound][30] = func() lib.Packet { return &ChangeGameState{} }
	packets[lib.Play][lib.Clientbound][31] = func() lib.Packet { return &KeepAliveClientbound{} }
	packets[lib.Play][lib.Clientbound][32] = func() lib.Packet { return &ChunkData{} }
	packets[lib.Play][lib.Clientbound][33] = func() lib.Packet { return &Effect{} }
	packets[lib.Play][lib.Clientbound][34] = func() lib.Packet { return &Particle{} }
	packets[lib.Play][lib.Clientbound][35] = func() lib.Packet { return &JoinGame{} }
	packets[lib.Play][lib.Clientbound][36] = func() lib.Packet { return &Maps{} }
	packets[lib.Play][lib.Clientbound][37] = func() lib.Packet { return &EntityMove{} }
	packets[lib.Play][lib.Clientbound][38] = func() lib.Packet { return &EntityLookAndMove{} }
	packets[lib.Play][lib.Clientbound][39] = func() lib.Packet { return &EntityLook{} }
	packets[lib.Play][lib.Clientbound][40] = func() lib.Packet { return &Entity{} }
	packets[lib.Play][lib.Clientbound][41] = func() lib.Packet { return &VehicleMove{} }
	packets[lib.Play][lib.Clientbound][42] = func() lib.Packet { return &SignEditorOpen{} }
	packets[lib.Play][lib.Clientbound][43] = func() lib.Packet { return &PlayerAbilities{} }
	packets[lib.Play][lib.Clientbound][44] = func() lib.Packet { return &CombatEvent{} }
	packets[lib.Play][lib.Clientbound][45] = func() lib.Packet { return &PlayerInfo{} }
	packets[lib.Play][lib.Clientbound][46] = func() lib.Packet { return &TeleportPlayer{} }
	packets[lib.Play][lib.Clientbound][47] = func() lib.Packet { return &EntityUsedBed{} }
	packets[lib.Play][lib.Clientbound][48] = func() lib.Packet { return &EntityDestroy{} }
	packets[lib.Play][lib.Clientbound][49] = func() lib.Packet { return &EntityRemoveEffect{} }
	packets[lib.Play][lib.Clientbound][50] = func() lib.Packet { return &ResourcePackSend{} }
	packets[lib.Play][lib.Clientbound][51] = func() lib.Packet { return &Respawn{} }
	packets[lib.Play][lib.Clientbound][52] = func() lib.Packet { return &EntityHeadLook{} }
	packets[lib.Play][lib.Clientbound][53] = func() lib.Packet { return &WorldBorder{} }
	packets[lib.Play][lib.Clientbound][54] = func() lib.Packet { return &Camera{} }
	packets[lib.Play][lib.Clientbound][55] = func() lib.Packet { return &SetCurrentHotbarSlot{} }
	packets[lib.Play][lib.Clientbound][56] = func() lib.Packet { return &ScoreboardDisplay{} }
	packets[lib.Play][lib.Clientbound][57] = func() lib.Packet { return &EntityMetadata{} }
	packets[lib.Play][lib.Clientbound][58] = func() lib.Packet { return &EntityAttach{} }
	packets[lib.Play][lib.Clientbound][59] = func() lib.Packet { return &EntityVelocity{} }
	packets[lib.Play][lib.Clientbound][60] = func() lib.Packet { return &EntityEquipment{} }
	packets[lib.Play][lib.Clientbound][61] = func() lib.Packet { return &SetExperience{} }
	packets[lib.Play][lib.Clientbound][62] = func() lib.Packet { return &UpdateHealth{} }
	packets[lib.Play][lib.Clientbound][63] = func() lib.Packet { return &ScoreboardObjective{} }
	packets[lib.Play][lib.Clientbound][64] = func() lib.Packet { return &Passengers{} }
	packets[lib.Play][lib.Clientbound][65] = func() lib.Packet { return &Teams{} }
	packets[lib.Play][lib.Clientbound][66] = func() lib.Packet { return &UpdateScore{} }
	packets[lib.Play][lib.Clientbound][67] = func() lib.Packet { return &SpawnPosition{} }
	packets[lib.Play][lib.Clientbound][68] = func() lib.Packet { return &TimeUpdate{} }
	packets[lib.Play][lib.Clientbound][69] = func() lib.Packet { return &Title{} }
	packets[lib.Play][lib.Clientbound][70] = func() lib.Packet { return &HardSoundEffect{} }
	packets[lib.Play][lib.Clientbound][71] = func() lib.Packet { return &PlayerListHeaderFooter{} }
	packets[lib.Play][lib.Clientbound][72] = func() lib.Packet { return &CollectItem{} }
	packets[lib.Play][lib.Clientbound][73] = func() lib.Packet { return &EntityTeleport{} }
	packets[lib.Play][lib.Clientbound][74] = func() lib.Packet { return &EntityProperties{} }
	packets[lib.Play][lib.Clientbound][75] = func() lib.Packet { return &EntityEffect{} }
}
